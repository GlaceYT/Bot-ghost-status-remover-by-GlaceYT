import { Collection as Collection$1 } from '@discordjs/collection';
import { inspect } from 'util';

declare class Collection<K = unknown, V = unknown> extends Collection$1<K, V> {
    #private;
    /**
     * @returns {Array<V>} Array of this collection
     */
    array(): V[];
    set(key: K, value: V): this;
    delete(key: K): boolean;
}

type QueueStrategy = 'LIFO' | 'FIFO';
type QueueItemFilter<T, R = boolean> = (value: T, idx: number, array: T[]) => R;
declare class Queue<T = unknown> {
    strategy: QueueStrategy;
    store: T[];
    constructor(strategy?: QueueStrategy, initializer?: T[]);
    get data(): T[];
    static from<T>(data: T[], strategy?: QueueStrategy): Queue<T>;
    isFIFO(): boolean;
    isLIFO(): boolean;
    add(item: T | T[]): void;
    clear(): void;
    shuffle(): void;
    remove(itemFilter: QueueItemFilter<T>): void;
    removeOne(itemFilter: QueueItemFilter<T>): void;
    find(itemFilter: QueueItemFilter<T>): T | undefined;
    filter(itemFilter: QueueItemFilter<T>): T[];
    some(itemFilter: QueueItemFilter<T>): boolean;
    every(itemFilter: QueueItemFilter<T>): boolean;
    map<R = T>(itemFilter: QueueItemFilter<T, R>): R[];
    at(idx: number): T | undefined;
    dispatch(): T | undefined;
    clone(): Queue<T>;
    get size(): number;
    toString(): string;
    toArray(): T[];
    toJSON(): T[];
    [inspect.custom](): string;
}

declare class EventEmitter<L extends ListenerSignature<L> = DefaultListener> {
    public static defaultMaxListeners: number;
    public constructor(options?: { captureRejections?: boolean });
    public addListener<U extends keyof L>(event: U, listener: L[U]): this;
    public prependListener<U extends keyof L>(event: U, listener: L[U]): this;
    public prependOnceListener<U extends keyof L>(event: U, listener: L[U]): this;
    public removeListener<U extends keyof L>(event: U, listener: L[U]): this;
    public removeAllListeners(event?: keyof L): this;
    public once<U extends keyof L>(event: U, listener: L[U]): this;
    public on<U extends keyof L>(event: U, listener: L[U]): this;
    public off<U extends keyof L>(event: U, listener: L[U]): this;
    public emit<U extends keyof L>(event: U, ...args: Parameters<L[U]>): boolean;
    public eventNames<U extends keyof L>(): U[];
    public listenerCount(type: keyof L): number;
    public listeners<U extends keyof L>(type: U): L[U][];
    public rawListeners<U extends keyof L>(type: U): L[U][];
    public getMaxListeners(): number;
    public setMaxListeners(n: number): this;
}

type ListenerSignature<L> = {
    [E in keyof L]: (...args: any[]) => any;
};

type DefaultListener = {
    [k: string]: (...args: any[]) => any;
};

declare function createEnum<K extends string | number | symbol>(data: K[]): Readonly<Record<K, K>>;

type PlayerExceptionMessage = string | Record<string, unknown>;
declare class PlayerException extends Error {
    constructor(message: PlayerExceptionMessage);
}

declare const version: string;

export { Collection, DefaultListener, EventEmitter, ListenerSignature, PlayerException, PlayerExceptionMessage, Queue, QueueItemFilter, QueueStrategy, createEnum, createEnum as keyMirror, version };
